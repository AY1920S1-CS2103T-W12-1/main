= FinSec - Developer Guide
:site-section: DeveloperGuide
:toc:
:toc-title:
:toc-placement: preamble
:sectnums:
:imagesDir: images
:stylesDir: stylesheets
:xrefstyle: full
ifdef::env-github[]
:tip-caption: :bulb:
:note-caption: :information_source:
:warning-caption: :warning:
endif::[]
:repoURL: https://github.com/AY1920S1-CS2103T-W12-1/main

By: `AY1920S1-CS2103T-W12-1`      Since: `Aug 2019`      Licence: `MIT`

== Design

[[Design-Architecture]]
=== Architecture

.Architecture Diagram
image::ArchitectureDiagram.png[]

The *_Architecture Diagram_* given above explains the high-level design of the App. Given below is a quick overview of each component.

`Main` has two classes called link:{repoURL}/src/main/java/seedu/address/Main.java[`Main`] and link:{repoURL}/src/main/java/seedu/address/MainApp.java[`MainApp`]. It is responsible for,

* At app launch: Initializes the components in the correct sequence, and connects them up with each other.
* At shut down: Shuts down the components and invokes cleanup method where necessary.

<<Design-Commons,*`Commons`*>> represents a collection of classes used by multiple other components.
The following class plays an important role at the architecture level:

* `LogsCenter` : Used by many classes to write log messages to the App's log file.

The rest of the App consists of four components.

* <<Design-Ui,*`UI`*>>: The UI of the App.
* <<Design-Logic,*`Logic`*>>: The command executor.
* <<Design-Model,*`Model`*>>: Holds the data of the App in-memory.
* <<Design-Storage,*`Storage`*>>: Reads data from, and writes data to, the hard disk.

Each of the four components

* Defines its _API_ in an `interface` with the same name as the Component.
* Exposes its functionality using a `{Component Name}Manager` class.

For example, the `Logic` component (see the class diagram given below) defines it's API in the `Logic.java` interface and exposes its functionality using the `LogicManager.java` class.

.Class Diagram of the Logic Component
image::LogicClassDiagram.png[]

[discrete]
==== How the architecture components interact with each other

The _Sequence Diagram_ below shows how the components interact with each other for the scenario where the user issues the command `delete 1`.

.Component interactions for `delete 1` command
image::ArchitectureSequenceDiagram.png[]

The sections below give more details of each component.

[[Design-Ui]]
=== UI component

.Structure of the UI Component
image::UiClassDiagram.png[]

*API* : link:{repoURL}/src/main/java/seedu/address/ui/Ui.java[`Ui.java`]

The UI consists of a `MainWindow` that is made up of parts e.g.`CommandBox`, `ResultDisplay`, `PersonListPanel`, `StatusBarFooter` etc. All these, including the `MainWindow`, inherit from the abstract `UiPart` class.

The `UI` component uses JavaFx UI framework. The layout of these UI parts are defined in matching `.fxml` files that are in the `src/main/resources/view` folder. For example, the layout of the link:{repoURL}/src/main/java/seedu/address/ui/MainWindow.java[`MainWindow`] is specified in link:{repoURL}/src/main/resources/view/MainWindow.fxml[`MainWindow.fxml`]

The `UI` component,

* Executes user commands using the `Logic` component.
* Listens for changes to `Model` data so that the UI can be updated with the modified data.

[[Design-Logic]]
=== Logic component

[[fig-LogicClassDiagram]]
.Structure of the Logic Component
image::LogicClassDiagram.png[]

*API* :
link:{repoURL}/src/main/java/seedu/address/logic/Logic.java[`Logic.java`]

.  `Logic` uses the `AddressBookParser` class to parse the user command.
.  This results in a `Command` object which is executed by the `LogicManager`.
.  The command execution can affect the `Model` (e.g. adding a person).
.  The result of the command execution is encapsulated as a `CommandResult` object which is passed back to the `Ui`.
.  In addition, the `CommandResult` object can also instruct the `Ui` to perform certain actions, such as displaying help to the user.

Given below is the Sequence Diagram for interactions within the `Logic` component for the `execute("delete 1")` API call.

.Interactions Inside the Logic Component for the `delete 1` Command
image::DeleteSequenceDiagram.png[]

NOTE: The lifeline for `DeleteCommandParser` should end at the destroy marker (X) but due to a limitation of PlantUML, the lifeline reaches the end of diagram.

[[Design-Model]]
=== Model component

.Structure of the Model Component
image::ModelClassDiagram.png[]

*API* : link:{repoURL}/src/main/java/seedu/address/model/Model.java[`Model.java`]

The `Model`,

* stores a `UserPref` object that represents the user's preferences.
* stores the Address Book data.
* exposes an unmodifiable `ObservableList<Person>` that can be 'observed' e.g. the UI can be bound to this list so that the UI automatically updates when the data in the list change.
* does not depend on any of the other three components.

[NOTE]
As a more OOP model, we can store a `Tag` list in `Address Book`, which `Person` can reference. This would allow `Address Book` to only require one `Tag` object per unique `Tag`, instead of each `Person` needing their own `Tag` object. An example of how such a model may look like is given below. +
 +
image:BetterModelClassDiagram.png[]

[[Design-Storage]]
=== Storage component

.Structure of the Storage Component
image::StorageClassDiagram.png[]

*API* : link:{repoURL}/src/main/java/seedu/address/storage/Storage.java[`Storage.java`]

The `Storage` component,

* can save `UserPref` objects in json format and read it back.
* can save the Address Book data in json format and read it back.

[[Design-Commons]]
=== Common classes

Classes used by multiple components are in the `seedu.addressbook.commons` package.

== Implementation

This section describes some important details on how the features are implemented

=== Claim feature

The `add_claim` command allows for admins to register Claims into FinSec.

The format for the `add_claim` command is as follows:

 add_claim d/<DESCRIPTION> c/<CASH AMOUNT> date/<DATE> n/<NAME> p/<PHONE NUMBER>

==== Adding a Claim

*Overview*

The add claim `add_claim` mechanism is facilitated by `AddClaimCommand` and `AddClaimCommandParser`, taking in the
following input from the user: `Description`, `Amount`, `Date`, `Name` and `Phone`, which will construct `Claim` objects.

.Add Claim Command Sequence Diagram
image::AddClaimSequenceDiagram.png[]

.Add Claim Command Sequence Diagram (extension)
image::AddClaimSequenceDiagram_Model.png[]

The `AddClaimCommandParser` implements `Parser` with the following operation:

* `AddClaimCommandParser#parse()` - This operation will take in a String input from the user that will create `Claim`
objects based on the prefixes 'd/', 'c/', 'date/', 'n/' and 'p/'. The String value after the individual prefixes will
create the respective object: d/`description`, c/`amount`, date/`date`,  n/`name` and p/`phone`. A regex validation
check will be imposed upon the creation of each argument. Any checks that fails the validation would prompt the user on
the failed component.

For example:

** `date` would use `ParseUtil#parseDate()` to ensure that the date entered is in the correct format of DD-MM-YYYY.

** `amount` would use `ParserUtil#parseAmount()` to ensure that cash amount would only contain numbers and a maximum of
2 decimal places.

** `phone` would use `ParserUtil#parsePhone()` to ensure that the phone number entered would only contain numbers that
are at least 3 numbers long.

* After validation checks are completed with no errors, a `Claim` object will be constructed with `Id`, `Description`,
`Amount`, `Date`, `Name` and `Phone` as the parameters.

* `AddClaimCommandParser` would then return an `AddClaimCommand` object with `Claim` as its attribute.

* `AddClaimCommand#execute` checks against all existing contacts against the inputs `name` and `phone` to make sure
the contact exists.

*Example*

Given below is an example usage scenario of how `add_claim` mechanism behaves at each step.

*Step 1:* The user executes:
....
add_claim d/Logistics for Sports Day c/150.60 date/21-12-2019 n/Melissa p/99875432`
....
This adds a `Claim` of $150.60 for Logistics for Sports Day by Melissa, with a phone identity of 99875432.

*Step 2:* `LogicManager` would use `FinSecParser#parse()` to parse input from the user.

*Step 3:* `FinSecParser` would determine which command is being used and creates the respective parser. In this case,
`AddClaimCommandParser` is being created and the user's input would be passed in as a parameter.

*Step 4:* `AddClaimCommandParser` would do a validation check on the user's input before creating and returning a
`AddClaimCommand` object with `Claim` as its attribute.

*Step 5:* `LogicManager` would execute `AddClaimCommand#execute()`, checking whether there is an existing Claim and also
whether there is an existing contact for the claim, then adding the `PendingClaim` into the `Model` which is handled by the
`ModelManager`.

*Step 6:* `AddClaimCommand` would return a `CommandResult` to the `LogicManager` which would then be returned back to
the user.


==== Approving a Claim

This feature allows the user to approve a `PendingClaim` from the `UniqueClaimList` through its index.

The approve claim feature is facilitated by the `ApproveClaimCommandParser` and the `ApproveClaimCommand`.

The `ApproveClaimCommand` is part of the logic component of our application. It interacts with the model and storage
components of our application.

==== Rejecting a Claim

This feature allows the user to reject a `PendingClaim` from the `UniqueClaimList` through its index.

The approve claim feature is facilitated by the `RejectClaimCommandParser` and the `RejectClaimCommand`.

The `RejectClaimCommand` is part of the logic component of our application. It interacts with the model and storage
components of our application.

=== Income feature

The `add_income` command allows for users to register new `Income` objects into FinSec.

The format for the `add_income` command is as follows:

....
`add_income d/<description> c/<cash amount> date/<date> n/<name> p/<phone number>`
....

==== Adding an Income

*Overview*

The add income `add_income` mechanism is facilitated by `AddIncomeCommand` and `AddIncomeCommandParser`. It takes in the following input from the user:
`description`, `cash amount`, `name` and `phone number`, which will construct individual objects that construct an `Income` object.

The `AddIncomeCommandParser` implements `Parser` with the following operation:


* `AddIncomeCommandParser#parse()` - This operation will take in a `String` input from the user that will create individual objects based on the prefixes 'd/', 'c/', 'date/', 'n/' and 'p/'. The `String` value after the individual prefixes will create
the respective object: d/ `description`, c/ `cash amount`, date/`date`,  n/ `name` and p/ `phone`. A validation check will be imposed upon the creation of each object. Any checks that fails the validation would prompt the user on the failed component.
For example:

** `cash amount` would use `ParserUtil#parseAmount()` to ensure that cash amount would only contain numbers and a maximum of 2 decimal places.

** `phone` would use `ParserUtil#parsePhone()` to ensure that the phone number entered would only contain numbers that are at least 3 numbers long.

** `date` would use `ParseUtil#parseDate()` to ensure that the date entered is in the correct format of DD-MM-YYYY.

* After validation checks are completed with no errors, an `Income` object is then constructed with `description`, `cash`, `date`, `name` and `phone` as the parameters.

* `AddIncomeCommandParser` would then return a `AddIncomeCommand` object with `Income` as the parameter.

*Example*

Given below is an example usage scenario of how `add_income` mechanism behaves at each step.

*Step 1:* The user executes `add_income d/shirt sales c/100.05 date/11-11-2019 n/John Doe p/91111111` to add an income of $100.05 of shirt sales received from John Doe who is contactable at 91111111.

*Step 2:* `LogicManager` would use `FinSecParser#parse()` to parse input from the user.

*Step 3:* `FinSecParser` would determine which command is being used and creates the respective parser. In this case, `AddIncomeCommandParser` is being created and the user's input would be passed in as a parameter.

*Step 4:* `AddIncomeCommandParser` would do a validation check on the user's input before creating and returning a `AddIncomeCommand` object with `Income` as the parameter.

*Step 5:* `LogicManager` would use `AddIncomeCommand#execute()` to add the `Income` into the `Model` which is handled by the `ModelManager`.

*Step 6:* `AddIncomeCommand` would return a `CommandResult` to the `LogicManager` which would then be returned back to the user.

.Add Income Command Sequence Diagram
image::AddIncomeSequenceDiagram.png[]

==== Deleting an Income

This feature allows the user to delete an income entry from the Unique Incomes List through its index.

The delete income feature is facilitated by the `DeleteIncomeCommandParser` and the `DeleteIncomeCommand`.

The delete income command is part of the logic component of our application. It interacts with the model and storage components of our application.

*Overview*

The `DeleteIncomeCommandParser` implements `Parser` with the following operation:

* `DeleteIncomeCommandParser#parse()` - This operation will take in a `int` input from the user which will delete the income entry at the index which has entered.
Any invalid format of the command will be prompted by the command parser.

*Current Implementation*

The delete income feature is executed by the `DeleteIncomeCommand`. Currently, the deletion of any income entry is done based on the `INDEX` of the income entry.

During the design of our delete function, we considered between two alternatives.

.Delete function alternatives
[options="header,footer"]
|=======================
| Design Consideration | Pros and Cons
| Deletion by Index (Current Choice)   | *Pros* : Since each income has a unique index, any deletion by the index is less prone to bugs and easier to implement.

                                        *Cons* : User will have to scroll the income list for the income entry and look for its index which can be inconvenient.

| Deletion by Income description     | *Pros* : It may be more intuitive for users to delete an income through the description of the income.
                                        *Cons* : Incomes of different entries can have similar description. The user would eventually still have to look through the income list.
|=======================

We have decided to opt for the first option primarily because it reduces the number of potential bugs and the complexities involved when taking into account the different cases and scenarios upon using deletion by income description.


==== Editing an Income

This feature allows the user to edit any attribute of the income entries. There are a total of five attributes for each entry, the description of the income, the amount of money received, the date it was received, the name of the person / organisation the user
received the money from and the contact number. The user can edit at least one and up to all attributes.

The edit income feature is facilitated by the `EditIncomeCommandParser` and the `EditIncomeCommand`.

The edit command is part of the logic component of our application. It interacts with the model component of our software architecture.

*Overview*

The `EditIncomeCommandParser` implements `Parser` with the following operation:

* `EditIncomeCommandParser#parse()` - This operation will take in an `int` input and one to five `String` input(s) from the user that will alter the attributes of current income entries based on the prefixes 'd/', 'c/', 'date/', 'n/', 'p'. The `String`
value after the individual prefixes will alter the respective attribute it corresponds to: 'd/' for `Description`, 'c/' for `Amount`, 'date/' for `Date`, 'n/' for `Name` and 'p/' for `Phone`. A validation check will be imposed upon editing of each object. Any checks that fails
the validation would prompt the user on the failed component.

*Current Implementation*

Here is an example of a step-by-step process on how the edit command alters an attribute of the homework entry. For each step, you may follow the activity diagram at the end of this section to better understand the flow of events within FinSec when an edit_income command is entered.

*Step 1 :* The user launches the application and nagivates to the income page. There is a list of existing income entries in FinSec.

*Step 2 :* The user then wishes to alter the income description of the second entry in the income list to "Fundraising". He then types `edit_income 2 d/Fundraising` into the Command Line Interface(CLI) and executes it.

*Step 3 :* The FinSecParser (refer to logic) then reads in these attributes that have been entered and proceeds to alter the attributes of the income entry in the given index. Each attribute will be validated.

*Step 4 :* The FinSecParser then creates a new EditIncomeCommand based on the input of the user. When the EditIncomeCommand is executed, it interacts with the Model architecture by calling the setIncome method. The setIncome method replaces the current income entry with the new income entry containing all the desired attributes. The income entry is now updated.

//enter activity diagram for edit income


=== Shortcut feature

This feature gives the user an option to create a shortcut when an unknown command is entered into FinSec.

*Overview*

To enable an easy implementation of this feature, we have created a TreeMap to store the default commands and shortcuts in the `FinSecParser`. Each command and shortcut have their Command Word stored as they key value (so as to ensure there are no duplicates) and Command task as the values.

All default commands and shortcuts are also initialised as `CommandItem` objects which would be handled by the `Model Manager` class whenever we add or delete a shortcut. Command classes such as `ShortCutRequestCommand`, `CreateShortcutCommand` and `NoShortCutCommand` are created to facilitate the
implementation of the shortcut feature.

When a user enters a command, `FinSecParser` would parse the input and check if the first word of the input is in the TreeMap key set. If the command word is not in the key set, FinSec would create a `ShortCutRequestCommand` and return the `ShortCutRequestCommand` object with `CommandWord` as the parameter.

*Example*

Given below is an example usage scenario of how the shortcut feature mechanism behaves at each step.

*Step 1 :* The user launches FinSec for the first time. The `FinSecParser` will be initialised. All the default commands will be added to the TreeMap using `FinSecParser#initialiseDefaultCommands()`. Previously created shortcuts would be added to the TreeMap from the constructor of the `FinSecParser`, where the ObservableList<CommandItem> will be the parameter.

*Step 2 :* The user enters an unknown command that is not recognised by FinSec. FinSec then returns a `ShortCutRequestCommand`.

*Step 3 :* `ShortCutRequestCommand` is executed in `LogicManager` and LogicManager would save the command word in a Stack. A `CommandResult` with a new Boolean value of "createShortCut" is then returned to `MainWindow` to display the result of the entry. The `CommandResult#isCreateShortCut()` sets the `MainWindow#unknownEntry` to true.

*Step 4 :* Since now the boolean value of `MainWindow#unknownEntry` is true, the next input would use a different execute command. Instead of the usual method `LogicManager#execute(String command)`, the next input would be executed by `LogicManager#executeUnknownInput(String command)`. Hence, if the subsequent input by the user is `n`, a `NoShortCutCommand` would be executed
and it would return a `CommandResult` with a false value of `createShortCut` which would reinstate back the normal state of FinSec.

*Step 5 :* If the user enters a value other than `n`, the `LogicManager#executeUnknownInput(String command)` would call `FinSecParser#checkCommand(String currentInput, String prevInput)` to check if the command is existing or not. If the command is existing, it would return another `ShortCutRequestCommand` object with the same input. However, if a valid defaul command is entered, a new `CreateShortCutCommand` object is returned.

*Step 6 :* When a `CreateShortCutCommand` object is returned, it is executed in `LogicManager` and `LogicManager` would use `CreateShortCutCommand#execute()` to add the `CommandItem` into the `Model` which is handled by the `ModelManager`.

*Step 7 :* `CreateShortCutCommmand` would then return a `CommandResult` to the `LogicManager` which would then be returned back to the user.

The following activity diagram summarises what happens when a user executes an unknown command:



=== Budget feature

The `budget` command allows for users to Generate a `Budget` object in FinSec. It also creates `Budget Graph` object and displays it via the User Interface.

==== Overview
The `Budget` feature relies primarily on the `Claim` and `Income` features, and serves as an extension to calculate their difference.
The `Budget` object calculates the cash `amount` values all existing `Income` objects and all cash `amount` values of `Claims` that have a `status` of `approved`.
It then returns the difference in values as the `budget` value and creates a graph detailing the statistics for the month.

==== Current Implementation
<<budgetSeqDiagram>> is a sequence of steps that illustrates the interaction between various classes when the `budget`
command is entered.
[[budgetSeqDiagram]]
[reftext="Figure 2.3.2.1"]
[caption="Figure 2.3.2.1: "]
.Execution sequence of the `budget` command
image::BudgetSequenceDiagram.png[width="800"]

1) The `budget` command is passed on to the `LogicManager` as `commandText` +

2) The LogicManager::execute method then calls FinSecParser::parseCommand which receives the user input (`budget`) as a parameter. +

3) FinSecParser then references the various command words and identifies the command to be a `budget` command.

4) FinSecParser then calls the `BudgetCommand` method.

5) This newly created `BudgetCommand` object is returned to the LogicManager instance through the GotoCommandParser and FinSecParser objects.

5) In the LogicManager object, it then calls the BudgetCommand::execute method

6) The `BudgetCommand` then interacts with the model component of our software architecture to create a filteredList of all `Income` and `Claim` objects using the `model.getFilteredClaimList()` and `model.getFilteredIncomeList()` commands

7) It then parses the lists into to instantiate a `Budget` object and a `BudgetGraph` object

8) The `Budget` object contains classes such as `calculateTotalExpenses()` and `calculateBudget()` to calculate the `Amount` values of all the `Claims`, `Incomes` and thus use them to find the budget amount.

9) The `BudgetCommand` class then calls these methods and constructs a message string containing all these values

10) At the same time, the `BudgetGraph` object is instantiated, which is basically an XY-graph.

11) The `BudgetGraph` object creates a dataset by taking in the list of `Claims` and `Incomes` and parsing them to the `ClaimPlotter`, `IncomePlotter` and `BudgetPlotter` classes.

12) The 3 plotter classes then filter their respective lists to create new lists for the current month and start adding the points to the series.

* The code snippet below shows the `ClaimPlotter::plotClaims` method +

[source, java]

XYSeries plotClaims() {
        findClaimValueAtStartOfMonth();
        claimSeries.add(1, startingExpenses);
        double currentExpenses = startingExpenses;
        List<Claim> approvedClaimsInCurrentMonthList = findApprovedClaimsInCurrentMonth();
        for (Claim claim : approvedClaimsInCurrentMonthList) {
            for (int day = 2; day <= 31; day++) {
                if (claim.getDate().date.getDayOfMonth() == day) {
                    currentExpenses += Double.parseDouble(claim.getAmount().value);
                }
                claimSeries.add(day, currentExpenses);
            }
        }
        return claimSeries;
    }

13) Once the 3 series have been returned, the BudgetGraph then returns the completed dataset to the `BudgetGraph` class which then renders the image.

14) The `BudgetCommand::execute` method then calls the `BudgetGraph::displayBudgetGraph` method to display the graph image.

15) The `BudgetCommand::execute` finally completes by returning a new `CommandResult` with the specific message string to its calling method which is `LogicManager::execute`.

16) `LogicManager::execute` method returns a `CommandResult` to the calling method which is `MainWindow::executeCommand`

17) The specific feedback is then retrieved through `CommandResult::getFeedbackToUser` and set in the result display of the MainWindow.


==== Why was it implemented this way?
With so many claims and incomes, all having differing dates, it can be hard to keep track of how much money one should have on hand at any one time.

* We felt that while knowing how much our prospective budget would be is good, knowing it over a range of time (such as a month in the case of `BudgetGraph`) would help with better planning

* We also wanted to keep track of the history of said `Claims` and `Incomes` and doing it over a 1 month period ensures there will not be too visual data cluttering the screen.

==== Alternatives Considered
* We had intended on including separate graphs based on organisation tags so instead of having budget-time graphs, we would have a budget graph for every organisation. The idea was scrapped due to it being too convoluted.

=== Goto feature
This section describes the different Views that Goto can bring a user to. It includes an overview of the goto details and how users can interact
with goto based on commands implemented with the revamp of the original list feature.
It also provides some design considerations to give users an insight of how the current solutions are worked out.

==== Overview
There are various message attributes in goto command: `MESSAGE_SUCCESS_CONTACTS`, `MESSAGE_SUCCESS_CLAIMS`, `MESSAGE_SUCCESS_INCOMES`, `MESSAGE FAILURE`,
`MESSAGE_USAGE` that informs the user if the changing of View is successful. The attribute `View` is also stored as an attribute
of the command. It is taken in as the parameter and the index of this View determines the list that will be shown in the MainWindow.

==== Current Implementation
Figure 2.4.2.1 is a sequence of steps that illustrates the interaction between various classes when the `goto` command is entered.
`goto claims`

<<gotoSeqDiagram>> is a sequence of steps that illustrates the interaction between various classes when the `goto contacts`
command is entered.
[[gotoSeqDiagram]]
[reftext="Figure 2.4.2.1"]
[caption="Figure 2.4.2.1: "]
.Execution sequence of the `goto contacts` command
image::GotoSequenceDiagram.png[width="800"]

1) The only parameter after the goto command in the user input is passed into the LogicManager::execute method of the LogicManager instance. +

2) The LogicManager::execute method calls FinSecParser::parseCommand which receives the user input as a parameter. +

* This user input which is in `String` format is then formatted, the first word before the space is taken as the command word
and the rest of the String is grouped together as the argument that will be used later by the GotoCommandParser.
* With the command word determined, the FinSecParser instance identifies the command as a `goto` command and constructs an
instance of the GotoCommandParser.

3) FinSecParser calls the GotoCommandParser::parse method. This instance of GotoCommandParser then takes in the rest of the string,
in this case: `claims` +

* A `View` instance is then created when the ParserUtil:parseView method is called. This method takes in the argument from the GotoCommandParser::parse method parameter
and returns a GotoCommand with the View instance. This View forms the gotoView attribute of this specific GotoCommand instance.

* When the argument for the GotoCommandParser::parse method is not recognised or present, a `ParseException` will be thrown with an error
message that asks for the proper usage of the goto Command.

4) This newly created GotoCommand object is returned to the LogicManager instance through the GotoCommandParser and FinSecParser objects.

5) In the LogicManager object, it then calls the `GotoCommand::execute` method

* The method takes in a `Model` object to access the application’s data context, the general storage of data for the application

* The activity diagram below shows the `GotoCommand::execute` method +

<<gotoActDiagram>> is the activity diagram of the goto command
[[gotoActDiagram]]
[reftext="Figure 2.5.2.2"]
[caption="Figure 2.5.2.2: "]
.ActivityDiagram
image::GotoActivityDiagram.png[width="800"]


* The model parameter passed into the `GotoCommand::execute` method is checked to be not null is made before the rest of the method continues.

* The `View::getIndex` method is then called to determine the gotoView for this current `GotoCommand` instance. There are 3 alternatives for
this command. They are `1, 2, 3`. These indexes refer to `contacts`, `claims` and `incomes` respectively.

6) Depending on which alternative is chosen based on the index of the gotoView, the `model` instance will then be updated with the correct list
of items.

* If the user wants to go to contacts, the `Model::updateFilteredContactList` method is called with a true predicate as the argument

* If the user wants to go to claims, the `Model::updateFilteredClaimList` method is called with a true predicate as the argument

* If the user wants to go to incomes, the `Model::updateFilteredIncomeList` method is called with a true predicate as the argument

* If the index that was retrieved through the `Model::getIndex` method is invalid or not within these 3 numbers, then a `CommandException` will
be thrown with the `MESSAGE_FAILURE` static attribute.

7) This `GotoCommand::execute` method completes by returning a new `CommandResult` with the specific success message to its calling method
which is `LogicManager::execute`.

8) `LogicManager::execute` method returns a `CommandResult` to the calling method which is `MainWindow::executeCommand`

* The specific feedback is then retrieved through `CommandResult::getFeedbackToUser` and set in the result display of the MainWindow.

==== Why was it implemented this way?
Our application allows for adding of claims and incomes, which are the extra features in comparison to the original AddressBook. Therefore, instead
of placing all of them into the same list

* We found the need to split them into 3 separate lists instead of placing them in the same window where a user sees 3 lists cluttered together.

* We want the user to have a clear command to know that he/she is no longer on the contacts list and has moved on to another list.

* In addition, with these new Views created, upon successful invocation of the `add_contacts`, `add_claim` or `add_income` methods by the user, the UI will
change automatically to either the contact, claims or incomes page. This gives the user a clear indication if the specific entry he/she has added
is successful.

==== Alternatives Considered
* We wanted to display 3 lists in the same main page, but that would cause the lists to be too crammed

* We wanted to reload the list on the current page to the various lists, but we believe that such a change in tabs will
help to tell the user that he is currently working on something different.

=== Check feature
This feature is an extended feature of the goto feature because this feature can only be run when
the user is in the claims or contacts page. This command is called when the user wants to check each contact or claim individually.

==== Overview
Just like the Goto Command, there are various message attributes: `MESSAGE_SUCCESS_CONTACT`, `MESSAGE_SUCCESS_CLAIM`, `MESSAGE_FAILURE`,
`MESSAGE_USAGE` that informs the user if the `check` command was successfully executed and if so which individual pop-up is showing. The 2 lists
that will benefit from these are the contacts and claims list. It is to allow the user to see a clear and concise understanding of the
individual claim or contact. It comes in the form of a pop-up that shows the most important attributes that belong to the claim or contact.

==== Current Implementation
The check command takes in a single parameter that is the `Index`.

Figure 2.5.2.1 is a sequence of steps that illustrates the interaction between various classes when the `check` command is entered.

<<checkSeqDiagram>> is a sequence of steps that illustrates the interaction between various classes when the `check 1`
command is entered.
[[checkSeqDiagram]]
[reftext="Figure 2.5.2.1"]
[caption="Figure 2.5.2.1: "]
.Execution sequence of the `check 1` command
image::CheckSequenceDiagram.png[width="800"]

1) The only parameter after the `check` command in the user input is passed into the LogicManager::execute method of the LogicManager instance. +

2) The LogicManager::execute method calls FinSecParser::parseCommand which receives the user input as a parameter. +

* This user input which is in `String` format is then formatted, the first word before the space is taken as the command word
and the rest of the String is grouped together as the argument that will be used later by the CheckCommandParser.
* With the command word determined, the FinSecParser instance identifies the command as a `check` command and constructs an
instance of the CheckCommandParser.

3) FinSecParser calls the CheckCommandParser::parse method. This instance of CheckCommandParser then takes in the rest of the string,
in this case: `1` +

* An `Index` instance is then created when the ParserUtil:parseIndex method is called. This method takes in the argument from the CheckCommandParser::parse method parameter
and returns a CheckCommand with the Index instance. This Index forms the index attribute of this specific CheckCommand instance.

* When the argument for the CheckCommandParser::parse method is not recognised or present, a `ParseException` will be thrown with an error
message that asks for the proper usage of the check Command.

4) This newly created CheckCommand object is returned to the LogicManager instance through the CheckCommandParser and FinSecParser objects.

5) In the LogicManager object, it then calls the `CheckCommand::execute` method

* The method takes in a `Model` object to access the application’s data context, the general storage of data for the application

* The Activity Diagram below shows the `CheckCommand::execute` method +

Figure 2.5.2.2 is the activity diagram of the check command

<<checkActDiagram>> is the activity diagram of the check command
[[checkActDiagram]]
[reftext="Figure 2.5.2.2"]
[caption="Figure 2.5.2.2: "]
.ActivityDiagram
image::CheckActivityDiagram.png[width="800"]

* The model parameter in the `CheckCommand::execute` method is checked to be not null is made before the rest of the method continues.

* The method `UiManager::getState` is called to ensure the state of the current `View` is one of the 2, namely `contacts` or `claims`.

6) Depending on which alternative is chosen based on the index of the gotoView, the `model` instance will then be updated with the correct list
of items.

* If the user is in the claims list, the method `Model::getFilteredClaimList` is called to get the latest list of claims

* The specific `claimToShow` is then retrieved through the `get` method from the list

* An instance of `CommandResult` is then returned with the specific success message, the boolean for showClaim in the `CommandResult` constructor
to be set to true and this `claimToShow` is passed into the constructor as a parameter.

* If the index that was retrieved through the `Model::getIndex` method is invalid or larger than the size of the list, then a `CommandException` will
be thrown with the `MESSAGE_FAILURE` static attribute.

7) This `GotoCommand::execute` method completes by returning a new `CommandResult` with the specific success message to its calling method
which is `LogicManager::execute`.

8) `LogicManager::execute` method returns a `commandResult` instance to the calling method which is `MainWindow::executeCommand`

* The specific feedback is then retrieved through `CommandResult::getFeedbackToUser` and set in the result display of the MainWindow.

9) The methods `CommandResult::isClaim` or `CommandResult::isContact` are then invoked to check if this `commandResult` instance is a `claim` or a `contact`
then the methods `CommandResult::giveClaim` or `CommandResult::giveContact` are called to give the specific objects respectively. Either of these objects
will then be passed as parameter to the `ModelManager::handleClaim` or `Model::handleContact` methods.

10) The code snippet below shows the `Model::handleClaim` method +

[source, java]

@FXML
    public static void handleClaim(Claim claim) {
        IndividualClaimWindow individualClaimWindow = new IndividualClaimWindow(claim);
        if (!individualClaimWindow.isShowing()) {
            individualClaimWindow.show();
        } else {
            individualClaimWindow.focus();
        }
    }

* This method creates a new `IndividualClaimWindow` with the claim object that was passed as a parameter. If the window is not showing, the
`IndividualClaimWindow::show` method is called else it will call the `IndividualClaimWindow::focus` method to focus on the current claim.

==== Why was it implemented this way?
The pop-up method seems to be the best way to attract the attention of the user and make sure that the user can see clearly what he wants to
check at that point in time. A pop-up is also easy because it allows the user to return immediately to the lists of claims or contacts and he/she
can continue to work on his tasks immediately.

==== Alternative Considered
* We also considered that upon `check index`, it just removes the whole list from view and isolates the desired claim
or contact needed, but we realised that might not catch the attention of the user

=== Sort Feature
This section describes the ways that a user can sort the various lists. An overview is also included on how these sorts
work.
It also provides some design considerations to give users an insight of how the current solutions are worked out.
==== Overview
There are 2 ways that a user can sort the lists by. It gives the user flexibility in how he wants to see the lists. In
addition, after sorting, the user can then employ the check method once again to see each individual object.

==== Current Implementation
The sort command takes in a 1 parameter that is the `Filter`. This `Filter` can either be `name` or `date`.
`name` filter works in all 3 lists. However, in contacts and incomes list, the `name` filter refers to the name of
the contact and in claims list, `name` refers to the description of the claim.
`date` filter works in claims and incomes list and not in contacts list because contacts are not created
with a date.

1) The 2 parameters after the `sort` command in the user input are `name` and `date`

2) This command is then parsed in the same way as the rest of the commands

3) The Activity Diagram below shows the `SortCommand::execute` method +

<<sortActDiagram>> is the activity diagram of the check command
[[sortActDiagram]]
[reftext="Figure 2.7.2.1"]
[caption="Figure 2.7.2.1: "]
.SortActivityDiagram
image::SortActivityDiagram.png[width="800"]

4) To elaborate, once the sort command is called, `UiManager::getState` method is called to determine the current view
the application is on then implements the correct type of sort on the list.

5) The comparators shown below are examples of the various lists are sorted.

* `sortFilteredClaimListByName` is implemented with the help of a comparator that compares the descriptions of each claim
with `claim.getDescription()` method. The code snippet below illustrates the comparator.

[source, java]
class ClaimNameComparator implements Comparator<Claim> {
    @Override
    public int compare(Claim claim1, Claim claim2) {
        return claim1.getDescription().toString().toUpperCase()
                .compareTo(claim2.getDescription().toString().toUpperCase());
    }
}

* `sortFilteredIncomeListByDate` is implemented with the help of a comparator that compares the dates of each income
with `income.getDate().getLocalDate()` method. The code snippet below illustrates the comparator.

[source, java]
class IncomeDateComparator implements Comparator<Income> {
    @Override
    public int compare(Income income1, Income income2) {
        return income1.getDate().getLocalDate()
                .compareTo(income2.getDate().getLocalDate());
    }
}

* `sortFilteredClaimListByStatus` is implemented with the help of a comparator that compares the statuses of each claim.
The order is as such: Pending, Approved, Rejected. There are 9 cases of comparison between 2 claims.
The code snippet below illustrates the comparator.

[source, java]
class ClaimStatusComparator implements Comparator<Claim> {
    @Override
    public int compare(Claim claim1, Claim claim2) {
        if (claim1.getStatus().equals(Status.PENDING) && claim2.getStatus().equals(Status.APPROVED)) {
            return -1;
        } else if (claim1.getStatus().equals(Status.PENDING) && claim2.getStatus().equals(Status.PENDING)) {
            return 0;
        } else if (claim1.getStatus().equals(Status.PENDING) && claim2.getStatus().equals(Status.REJECTED)) {
            return -1;
        } else if (claim1.getStatus().equals(Status.APPROVED) && claim2.getStatus().equals(Status.REJECTED)) {
            return -1;
        } else if (claim1.getStatus().equals(Status.APPROVED) && claim2.getStatus().equals(Status.APPROVED)) {
            return 0;
        } else if (claim1.getStatus().equals(Status.APPROVED) && claim2.getStatus().equals(Status.PENDING)) {
            return 1;
        } else if (claim1.getStatus().equals(Status.REJECTED) && claim2.getStatus().equals(Status.PENDING)) {
            return 1;
        } else if (claim1.getStatus().equals(Status.REJECTED) && claim2.getStatus().equals(Status.REJECTED)) {
            return 0;
        } else if (claim1.getStatus().equals(Status.REJECTED) && claim2.getStatus().equals(Status.APPROVED)) {
            return 1;
        } else {
            return 0;
        }
    }
}

==== Why was it implemented this way?
The major implementation difference for claims list sorted by `name`, it is sorted based on the description of each
claim. This was implemented like this because of the check feature. The check feature in the contacts list allows
the user to see what claims are under the user. When a user is in the claims page, he/she will only need to sort based
on descriptions to prevent redundant information through different commands.

The 2 different filters allow the user to be able to look through the lists based on what is important to him/her. `date`
filter is especially important so the user can check what are the latest or oldest claims. `name` filter helps the user
find the various contacts/claims/incomes. It doubles up as a find or filter function to let the user find the specific
object he/she is finding.

==== Alternative Considered
* Sorting of the claims list based on contact's name instead

=== Reverse feature
This feature is exactly identical in the implementation as compared to the above sort feature. This feature sorts the various
lists based on the same filters in the reverse of natural ordering. It shows the lists in reverse lexicographical order if
`name` is used as filter and shows the newest entry at the top and the oldest at the bottom of the list.

[appendix]
== Product Scope

*Target user profile*:

* has a need to manage a significant number of contacts, claim and income
* has to keep track of the budget for an organisation
* prefer desktop apps over other types
* can type fast and prefers typing over mouse input
* is reasonably comfortable using CLI apps
* has secretarial or finance management duties

*Value proposition*:

* Simplify the tasks of the finance secretary by providing intuitive commands to commonly done tasks (check net balance, show surplus, show deficit)
* Makes said task more cohesive by integrating 3 types of tracking (claims, budget and income) into a single application
* Provides convenience by making it easier to manage documents and accountability for money (Cash on-hand)
* Reduces the probability of mistakes made by the Finance Secretary by providing accurate tracking details of the various claims and accounts


[appendix]
== User Stories

Priorities: High (must have) - `* * \*`, Medium (nice to have) - `* \*`, Low (unlikely to have) - `*`

[width="59%",cols="22%,<23%,<25%,<30%",options="header",]
|=======================================================================
|Priority |As a ... |I want to ... |So that I can...
|`* * *` |user |ensure the contacts list to look like an address book still |easily access people I had dealt with before
|`* * *` |busy user |ensure the contacts list to have a filter/search bar |easily find people in my contacts list
|`* * *` |user |ensure the app can create Groups and Events such as Sports, Marketing, FOP etc |manage them easier
|`* * *` |user |ensure the app can categorise the people to the Groups and Events |manage them easier.
|`* * *` |user |ensure the app can help me record the amount of money I have on hand |manage it easier.
|`* * *` |busy user |ensure the app can help me record the amount of money I am supposed to have |manage it easier.
|`* * *` |user |ensure the app can help me calculate the difference of money I have vs the amount of money I am supposed to have |manage it easier.
|`* * *` |user |ensure the app can give me a warning when the difference of money I have on hand vs the amount of money I am supposed to have is not 0 |be notified if something like that does happen.
|`* * *` |user |ensure the app can show me the transactions I had with people in the past, even after the transaction is done |keep a history of them.
|`* * *` |user |ensure the app can show me a list of DONE people |manage them easier.
|`* * *` |user |ensure the app can show me a list of NOT DONE people |manage them easier.
|`* * *` |user |ensure the app can show me the date stamp of the transaction done |keep a history of them.
|`* * *` |user |ensure the app can sort the value of claims in ascending/descending order |manage them easier.
|`* * *` |user |ensure the app can be able to freely manipulate accessible data (add, delete, change name, change amount etc.) |manage them easier.
|`* * *` |clumsy user |ensure the app can app could detect any anomalies such as duplicate claims |make less mistakes.
|`* *` |user |ensure the app can be colorful and vibrant but not that painful to the eye |look at it without straining my eyes.
|`* *` |user |ensure the app can send notifications to my email for any major deadlines |manage them easier.
|`* *` |user |ensure the app can warn me when the particular group is going to exceed their budget at a certain threshold, like let’s say ($500 left) |be notified if something like that does happen.
|`* *` |user |ensure the app can show me the transaction sorted by month |manage it easier.
|`* *` |user |ensure the app can show a checklist of to-dos as a Finance Secretary |manage them easier.
|`* *` |fellow director of the organisation |ensure the app can transform into a to-do list for any other departments |manage them easier.
|`* *` |user |ensure the app can have graphical representation of data such as pie charts |look at it without straining my eyes.
|`* *` |lazy user |ensure the app can generate a pseudo report based on the claims |not have to do it myself.
|`* *` |clumsy user |ensure the app can perform periodic backups  |revert the data in the event that I mess up horribly.
|`* *` |superior of the finance secretary |have reading access to the information related to the budget, claims and deposits| check on the user's work.
|`*` |user |ensure the app can have some form of security |ensure no one can see the transactions I have done before
|`*` |lazy user |ensure the app can email the offending parties if there is a discrepancy or fault with the claims |not have to do it myself
|`*` |cautious finance secretary |ensure the app can check which secretary changed what details |hold them accountable for any foul play.
|`*` |cautious finance secretary |ensure the app can have an automated checking system |prevent embezzlement of funds.
|`*` |user |ensure the app can check for the petty cash holdings |keep track of all money including petty cash.
|`*` |user |ensure the app can have notifications when claims are left untouched for too long |be notified if something like that does happen.
|`*` |user |ensure the app can be customised to my needs |make the app suit me.

|=======================================================================



[appendix]
== Use Cases

(For all use cases below, the *System* is `FinSec` and the *Actor* is the `user`, unless specified otherwise)

[discrete]
=== Use case: Adding a contact

*MSS*

1. User requests to add a contact
2. FinSec adds a contact

+
Use case ends.

*Extensions*

[none]
* 1a. The contact details are existing.

[none]
** 1a1. FinSec shows an error message.
+
Use case resumes at step 1



[discrete]
=== Use case: Editing a contact

*MSS*

1. User requests to view list of contacts
2. FinSec shows a list of contacts
3. User requests which contact to edit and the details to change
4. FinSec edits the contact
+
Use case ends.

*Extensions*

[none]
* 2a. The list of contacts is empty.

User case ends

[none]
* 3a. The contact is not on the list.
+
[none]
** 3a1. FinSec shows an error message.
+
Use case resumes at step 2.


[discrete]
=== Use case: Delete contact

*MSS*

1.  User requests to list contacts
2.  FinSec shows a list of contacts
3.  User requests to delete a specific contact in the list
4.  FinSec deletes the contact
+
Use case ends.

*Extensions*

[none]
* 2a. The list is empty.
+
Use case ends.

* 3a. The given index is invalid.
+
[none]
** 3a1. FinSec shows an error message.
+
Use case resumes at step 2.


[discrete]
=== Use case: Goto view

*MSS*

1. User requests to change view (Contacts, Claims, Income)
2. FinSec brings user to that view
+
Use case ends.

*Extensions*

[none]
* 1a. The view is invalid.
+
Use case resumes at step 1.


[discrete]
=== Use case: Check details of person (Only available within Claims/Contacts lists)

*MSS*

1. User requests to view list of people
2. FinSec shows a list of people
3. User requests which person to check by index
4. FinSec displays person
+
Use case ends.

*Extensions*

[none]
* 2a. The person list is empty.
+
Use case ends.

[none]
* 3a. The index entered is invalid.
+
[none]
** 3a1. FinSec shows an error message.
+
Use case resumes at step 2.

[discrete]
=== Use case: Add Claim

*MSS*

1. User requests to add claim
2. FinSec adds claim

+
Use case ends.

*Extensions*

[none]
* 2a. The details of claim is invalid.
+
[none]
** 2a1. FinSec shows an error.
+
Use case resumes at step 1.

[discrete]
=== Use case: Edit Claim

*MSS*

1. User requests to view list of claims
2. FinSec shows a list of claims
3. User requests which claim to edit
4. FinSec edits claim
+
Use case ends.

*Extensions*

[none]
* 2a. The claim list is empty.
+
Use case ends.

[none]
* 3a. The entered claim is invalid.
+
[none]
** 3a1. FinSec shows an error message.
+
Use case resumes at step 2.


[discrete]
=== Use case: Add Income

*MSS*

1. User requests to add income
2. FinSec adds income

+
Use case ends.

*Extensions*

[none]
* 2a. The details of income is invalid.
+
[none]
** 2a1. FinSec shows an error.

Use case resumes at step 1.

[discrete]
=== Use case: Edit Income

*MSS*

1. User requests to view list of income
2. FinSec shows a list of income
3. User requests which income to edit
4. FinSec edits income
+
Use case ends.

*Extensions*

[none]
* 2a. The income list is empty.
+
Use case ends.

[none]
* 3a. The income entered is invalid.
+
[none]
** 3a1. FinSec shows an error message.
+
Use case resumes at step 2.



[discrete]
=== Use case: Check details of contact

*MSS*

1. User requests to view list of contacts
2. FinSec shows a list of contacts
3. User requests which contact to check by index
4. FinSec displays contact and details
+
Use case ends.

*Extensions*

[none]
* 2a. The contacts list is empty.
+
Use case ends.

[none]
* 3a. The index entered is invalid.
+
[none]
** 3a1. FinSec shows an error message.
+
Use case resumes at step 2.

[discrete]
=== Use case: Check status of claims of person

*MSS*

1. User requests to change view to Claims
2. FinSec changes view to claims
3. FinSec shows a list of claims
4. User requests which claim to check by index
5. FinSec displays details of particular claim
+
Use case ends.

*Extensions*

[none]
* 3a. The claims list is empty.
+
Use case ends.

[none]
* 4a. The index entered is invalid.
+
[none]
** 4a1. FinSec shows an error message.
+
Use case resumes at step 4.

[discrete]
=== Use case: Filter using keyword

*MSS*

1. User requests to view list of income, claims or contacts
2. FinSec shows the list
3. User requests to filter the list based on keyword
4. FinSec returns a list of filtered results
+
Use case ends.

*Extensions*

[none]
* 2a. The incomes, claims or contacts list is empty.
+
Use case ends.

[none]
* 3a. The keyword entered is yielded no result.
+
[none]
** 3a1. FinSec shows an error message.
+
Use case resumes at step 2.

[discrete]
=== Use case: See budget

*MSS*

1. User requests to view current budget
2. FinSec shows current budget

+
Use case ends.


[discrete]
=== Use case: Sort claims in chronological order

*MSS*

1. User requests to change view to claims
2. FinSec shows the claim view
3. User requests to sort the claims
4. FinSec shows sorted claims
+
Use case ends.

*Extensions*

[none]
* 2a. The claims list is empty.
+
Use case ends.

[discrete]
=== Use case: Resolving claims

*MSS*

1. User requests to change view to claims
2. FinSec shows the claim view
3. User requests to resolve claim from index
4. FinSec resolves claim
+
Use case ends.

*Extensions*

[none]
* 2a. The claims list is empty.
+
Use case ends.

[none]
* 3a. The index entered is invalid.
+
[none]
** 3a1. FinSec shows an error message.
+ Use case resumes at step 2.


[discrete]
=== Use case: Adding tags

*MSS*

1. User requests to view list of contacts
2. FinSec shows a list of contacts
3. User requests to add tags to contact
4. FinSec adds tags to the contact
+
Use case ends.

*Extensions*

[none]
* 2a. The contact list is empty.
+
Use case ends.

[none]
* 3a. The contact index is invalid.
+
[none]
** 3a1. FinSec shows an error message.
+ Use case resumes at step 2.

[appendix]
== Non Functional Requirements

.  Should work on any <<mainstream-os,mainstream OS>> as long as it has Java `11` or above installed.
.  Should be able to hold up to 1000 persons or claims without a noticeable sluggishness in performance for typical usage.
.  A user with above average typing speed for regular English text (i.e. not code, not system admin commands) should be able to accomplish most of the tasks faster using commands than using the mouse.
.  The system should work on both 32-bit and 64-bit environments.
.  The system should respond within two seconds.
.  The system should be intuitive and usable by anyone who can use excel.

[appendix]
== Glossary

[[budget]]Budget::
The total available budget of the organisation available for expenditure

[[income]]Income::
An income made by a contact that contributes to the income

[[claim]]Claim::
A claim made by a contact that deducts from the income

[[contact]]Contact::
A contact who may be claiming from or contributing income to the budget

[appendix]
== Product Survey

*Microsoft Excel*

Author: Microsoft

Pros:

* Very common application that can be found in any computer with Microsoft Office
* Able to customise formulas for calculation

Cons:

* Very bare-bones UI
* Multiple spreadsheets with multiple tabs can get very confusing

[appendix]
== Instructions for Manual Testing

Given below are instructions to test the app manually.

[NOTE]
These instructions only provide a starting point for testers to work on; testers are expected to do more _exploratory_ testing.

=== Launch and Shutdown

. Initial launch

.. Download the jar file and copy into an empty folder
.. Double-click the jar file +
   Expected: Shows the GUI with a set of sample contacts. The window size may not be optimum.

. Saving window preferences

.. Resize the window to an optimum size. Move the window to a different location. Close the window.
.. Re-launch the app by double-clicking the jar file. +
   Expected: The most recent window size and location is retained.

_{ more test cases ... }_

=== Deleting a person

. Deleting a person while all persons are listed

.. Prerequisites: List all persons using the `list` command. Multiple persons in the list.
.. Test case: `delete 1` +
   Expected: First contact is deleted from the list. Details of the deleted contact shown in the status message. Timestamp in the status bar is updated.
.. Test case: `delete 0` +
   Expected: No person is deleted. Error details shown in the status message. Status bar remains the same.
.. Other incorrect delete commands to try: `delete`, `delete x` (where x is larger than the list size) _{give more}_ +
   Expected: Similar to previous.

_{ more test cases ... }_

=== Saving data

. Dealing with missing/corrupted data files

.. _{explain how to simulate a missing/corrupted file and the expected behavior}_

_{ more test cases ... }_
